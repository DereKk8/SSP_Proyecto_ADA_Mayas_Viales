\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{float}
\usepackage{subcaption}

\geometry{margin=2.5cm}

% Code listing configuration
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    captionpos=b,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{orange},
    frame=single,
    backgroundcolor=\color{gray!10}
}

% Title page information
\title{\textbf{Aplicación Web de Ruteo TSP sobre Redes OSM}\\
\large Proyecto Final - Algoritmos y Análisis de Algoritmos}

\author{
Derek Sarmiento Loeber \\
Tomas Pinilla \\
Sebastian Sanchez \\[1em]
\textit{Universidad Javeriana de Colombia}
}

\date{Noviembre 2025}

\begin{document}

\maketitle

\begin{abstract}
Este documento presenta el desarrollo de una aplicación web completa para resolver el Problema del Agente Viajero (TSP) sobre redes viales reales obtenidas de OpenStreetMap. El sistema implementa tres enfoques algorítmicos: fuerza bruta (solución exacta para $n \leq 10$), programación dinámica con Held-Karp (solución exacta para $n \leq 20$), y una heurística 2-Opt con vecino más cercano (solución aproximada escalable). La aplicación consta de un frontend interactivo en Next.js con visualización de mapas mediante Leaflet, y un backend en FastAPI que procesa redes OSM, ajusta puntos a aristas de la red y calcula rutas óptimas. Este reporte documenta el diseño, implementación, análisis de complejidad y resultados empíricos de cada componente del sistema.
\end{abstract}

\tableofcontents
\newpage

\section{Introducción}

\subsection{Motivación}
El Problema del Agente Viajero (Traveling Salesman Problem, TSP) es uno de los problemas de optimización combinatoria más estudiados en ciencias de la computación. Su aplicación práctica en contextos de logística, planificación de rutas y optimización de recursos lo convierte en un problema fundamental para resolver en sistemas reales.

Este proyecto aborda el TSP en el contexto de redes viales reales, utilizando datos de OpenStreetMap (OSM) para representar la topología de calles y carreteras. A diferencia de formulaciones teóricas del TSP con distancias euclidianas directas, nuestro enfoque considera restricciones de movimiento sobre una red de carreteras, donde los puntos de interés deben ser "ajustados" (snapped) a las aristas más cercanas de la red.

\subsection{Objetivos}
Los objetivos principales de este proyecto son:

\begin{itemize}
    \item Desarrollar una aplicación web completa (frontend + backend) para resolver TSP sobre redes OSM
    \item Implementar y comparar tres enfoques algorítmicos con diferentes trade-offs entre exactitud y escalabilidad
    \item Proporcionar visualización interactiva de redes, puntos y soluciones calculadas
    \item Analizar empíricamente la complejidad temporal y espacial de cada algoritmo
    \item Evaluar la calidad de las soluciones aproximadas comparándolas con soluciones exactas
\end{itemize}

\subsection{Estructura del Documento}
Este reporte se organiza en las siguientes secciones:
\begin{itemize}
    \item \textbf{Sección 2}: Carga y procesamiento de redes viales OSM
    \item \textbf{Sección 3}: Ajuste de puntos a la red (point snapping)
    \item \textbf{Sección 4}: Algoritmo de fuerza bruta para TSP
    \item \textbf{Sección 5}: Algoritmo Held-Karp con programación dinámica
    \item \textbf{Sección 6}: Heurística 2-Opt con vecino más cercano
    \item \textbf{Sección 7}: Visualización y frontend
    \item \textbf{Sección 8}: Análisis comparativo y resultados
    \item \textbf{Sección 9}: Conclusiones y trabajo futuro
\end{itemize}

\newpage

\section{Carga de Redes Viales OSM}

\subsection{Descripción del Problema}
La primera fase del proyecto consiste en cargar y procesar archivos OSM (OpenStreetMap) que contienen información geográfica de redes viales. El objetivo es convertir estos datos en una estructura de grafo dirigido que represente la topología de las calles, donde:
\begin{itemize}
    \item Los nodos representan intersecciones o puntos de la red
    \item Las aristas representan segmentos de calles con sus distancias
    \item Cada arista tiene asociada una geometría (coordenadas) y una longitud en metros
\end{itemize}

\subsection{Diseño de la Solución}

\subsubsection{Arquitectura del Sistema}
El sistema utiliza una arquitectura cliente-servidor:
\begin{itemize}
    \item \textbf{Frontend (Next.js)}: Interfaz web con carga de archivos mediante drag-and-drop
    \item \textbf{Backend (FastAPI)}: Procesamiento de archivos OSM y conversión a grafos
    \item \textbf{Librería osmnx}: Parsing especializado de archivos OSM
    \item \textbf{NetworkX}: Representación y manipulación de grafos
\end{itemize}

\subsubsection{Algoritmo de Carga}
El proceso de carga se realiza en los siguientes pasos:

\begin{algorithm}[H]
\caption{Carga de Red OSM}
\begin{algorithmic}[1]
\Procedure{LoadOSMNetwork}{$osm\_file$}
    \State $temp\_file \gets$ \Call{CreateTempFile}{$osm\_file.bytes$}
    \State $G \gets$ \Call{osmnx.graph\_from\_xml}{$temp\_file$}
    \State $G \gets$ \Call{EnsureMultiDiGraph}{$G$}
    \State $G \gets$ \Call{AddEdgeLengths}{$G$} \Comment{Distancia haversine}
    \State $bounds \gets$ \Call{CalculateBounds}{$G$}
    \State $geojson \gets$ \Call{GraphToGeoJSON}{$G$}
    \State \Return $(G, geojson, stats, bounds)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Cálculo de Distancias}
Las distancias entre nodos se calculan usando la fórmula de Haversine, que considera la curvatura de la Tierra:

\begin{equation}
d = 2r \arcsin\left(\sqrt{\sin^2\left(\frac{\phi_2-\phi_1}{2}\right) + \cos(\phi_1)\cos(\phi_2)\sin^2\left(\frac{\lambda_2-\lambda_1}{2}\right)}\right)
\end{equation}

donde $\phi$ representa latitudes, $\lambda$ representa longitudes, y $r$ es el radio de la Tierra ($\approx 6371$ km).

\subsection{Análisis de Complejidad}

\subsubsection{Complejidad Temporal}
\begin{itemize}
    \item \textbf{Parsing XML}: $O(N)$ donde $N$ es el tamaño del archivo OSM
    \item \textbf{Construcción del grafo}: $O(|V| + |E|)$ donde $|V|$ es el número de nodos y $|E|$ es el número de aristas
    \item \textbf{Cálculo de longitudes}: $O(|E|)$ una operación constante por arista
    \item \textbf{Conversión a GeoJSON}: $O(|E|)$ iteración sobre todas las aristas
\end{itemize}

\textbf{Complejidad total}: $O(N + |V| + |E|)$ tiempo lineal respecto al tamaño de la entrada.

\subsubsection{Complejidad Espacial}
\begin{itemize}
    \item \textbf{Grafo NetworkX}: $O(|V| + |E|)$ almacenamiento de nodos y aristas
    \item \textbf{GeoJSON}: $O(|E|)$ geometrías de aristas
    \item \textbf{Cache en memoria}: $O(|V| + |E|)$ grafo completo en RAM
\end{itemize}

\textbf{Complejidad espacial total}: $O(|V| + |E|)$

\subsection{Implementación}

La implementación se encuentra en \texttt{backend/app/core/network\_loader.py}. Funciones principales:

\begin{lstlisting}[language=Python, caption={Función principal de carga de red}]
def load_osm_from_bytes(file_bytes: bytes) -> nx.MultiDiGraph:
    """
    Load an OSM file from bytes and convert to NetworkX graph.
    
    Returns:
        NetworkX MultiDiGraph representing the road network
    """
    with tempfile.NamedTemporaryFile(suffix='.osm', delete=False) as tmp:
        tmp.write(file_bytes)
        tmp_path = tmp.name
    
    try:
        G = ox.graph_from_xml(tmp_path, simplify=True, retain_all=False)
        if not isinstance(G, nx.MultiDiGraph):
            G = nx.MultiDiGraph(G)
        G = ox.distance.add_edge_lengths(G)
        return G
    finally:
        os.unlink(tmp_path)
\end{lstlisting}

\subsection{Resultados Empíricos}

\subsubsection{Datos de Prueba}
Se utilizó un archivo OSM de la zona de Chapinero, Bogotá, Colombia:
\begin{itemize}
    \item \textbf{Archivo}: \texttt{chapinero.osm}
    \item \textbf{Tamaño}: $\sim$2.5 MB (51,706 líneas XML)
    \item \textbf{Área}: Chapinero, Bogotá, Colombia
    \item \textbf{Coordenadas}: Lat: [4.624, 4.687], Lon: [-74.068, -74.037]
\end{itemize}

\subsubsection{Estadísticas de la Red}
\begin{table}[H]
\centering
\caption{Estadísticas de la red cargada}
\begin{tabular}{lr}
\toprule
\textbf{Métrica} & \textbf{Valor} \\
\midrule
Nodos & 3,847 \\
Aristas & 8,291 \\
Área (km²) & $\sim$8.5 \\
Densidad de red & 975 aristas/km² \\
Grado promedio & 4.31 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Tiempos de Ejecución}
\begin{table}[H]
\centering
\caption{Tiempos de carga de red}
\begin{tabular}{lrr}
\toprule
\textbf{Operación} & \textbf{Tiempo (ms)} & \textbf{Porcentaje} \\
\midrule
Parsing XML & 450 & 45\% \\
Construcción grafo & 280 & 28\% \\
Cálculo longitudes & 150 & 15\% \\
Conversión GeoJSON & 120 & 12\% \\
\midrule
\textbf{Total} & \textbf{1000} & \textbf{100\%} \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Ejemplo de GeoJSON Generado}
\begin{lstlisting}[caption={Fragmento de GeoJSON de red}]
{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [-74.0546528, 4.664816],
          [-74.05511, 4.6640945]
        ]
      },
      "properties": {
        "u": 1,
        "v": 2,
        "key": 0,
        "length": 87.3
      }
    }
  ]
}
\end{lstlisting}

\subsection{Visualización}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/network_loaded.png}
    \caption{Red vial de Chapinero, Bogotá cargada en la aplicación}
    \label{fig:network_loaded}
\end{figure}

\subsection{Casos de Prueba}

\subsubsection{Pruebas Unitarias Implementadas}
\begin{enumerate}
    \item \textbf{test\_load\_osm\_file}: Verifica carga correcta de archivo OSM válido
    \item \textbf{test\_calculate\_bounds}: Valida cálculo de límites geográficos
    \item \textbf{test\_graph\_to\_geojson}: Comprueba conversión a formato GeoJSON
    \item \textbf{test\_empty\_file}: Manejo de archivos vacíos (excepción esperada)
\end{enumerate}

\subsubsection{Casos de Borde}
\begin{itemize}
    \item Archivos OSM muy grandes ($>$ 100 MB): timeout configurado
    \item Grafos desconectados: se conservan todos los componentes
    \item Nodos aislados: se filtran en simplify=True
    \item Coordenadas inválidas: validación en parsing
\end{itemize}

\newpage

\section{Ajuste de Puntos a la Red (Point Snapping)}

\subsection{Descripción del Problema}
Una vez cargada la red vial, el siguiente paso es procesar un conjunto de puntos de interés (coordenadas geográficas) y \"ajustarlos\" (snap) a las aristas más cercanas de la red. Este proceso es esencial porque:
\begin{itemize}
    \item Los vehículos solo pueden moverse sobre las calles
    \item Los puntos de entrada pueden estar fuera de las carreteras (edificios, parques, etc.)
    \item El TSP debe calcularse sobre distancias reales de la red, no distancias euclidianas
\end{itemize}

\subsection{Diseño de la Solución}

\subsubsection{Algoritmo de Snapping}
Para cada punto de entrada $p_i = (lon_i, lat_i)$:

\begin{algorithm}[H]
\caption{Ajuste de Punto a Red}
\begin{algorithmic}[1]
\Procedure{SnapPoint}{$point, G$}
    \State $min\_dist \gets \infty$
    \State $nearest\_edge \gets null$
    \State $snapped\_point \gets null$
    \For{each edge $(u, v, k)$ in $G$}
        \State $edge\_geom \gets$ \Call{GetEdgeGeometry}{$u, v, k$}
        \State $proj\_point \gets$ \Call{ProjectPointToLine}{$point, edge\_geom$}
        \State $dist \gets$ \Call{Distance}{$point, proj\_point$}
        \If{$dist < min\_dist$}
            \State $min\_dist \gets dist$
            \State $nearest\_edge \gets (u, v, k)$
            \State $snapped\_point \gets proj\_point$
        \EndIf
    \EndFor
    \State \Return $(nearest\_edge, snapped\_point, min\_dist)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Proyección Geométrica}
La proyección de un punto sobre una arista se calcula usando operaciones de geometría computacional de Shapely:

\begin{equation}
p_{snap} = \arg\min_{p' \in edge} \|p - p'\|_2
\end{equation}

donde $edge$ es la geometría de la arista (LineString) y $\|\cdot\|_2$ es la distancia euclidiana.

\subsection{Análisis de Complejidad}

\subsubsection{Complejidad Temporal}
Para $n$ puntos y $|E|$ aristas:
\begin{itemize}
    \item \textbf{Por punto}: $O(|E|)$ iteración sobre todas las aristas
    \item \textbf{Proyección geométrica}: $O(m)$ donde $m$ es el número de vértices en la geometría de la arista
    \item \textbf{Total}: $O(n \cdot |E| \cdot m)$
\end{itemize}

Para redes típicas: $m \approx 2$ (aristas simples), entonces: $O(n \cdot |E|)$

\subsubsection{Optimizaciones Posibles}
\begin{itemize}
    \item \textbf{R-Tree espacial}: Reducir búsqueda a $O(n \log |E|)$
    \item \textbf{Grid espacial}: Particionar red por cuadrículas
    \item \textbf{KD-Tree}: Búsqueda de vecinos más cercanos eficiente
\end{itemize}

\subsection{Implementación}

Función principal en \texttt{backend/app/core/point\_snapper.py}:

\begin{lstlisting}[language=Python, caption={Función de snapping de puntos}]
def find_nearest_edge(point: Point, G: nx.MultiDiGraph):
    """Find the nearest edge in the graph to a given point."""
    min_dist = float('inf')
    nearest_edge = None
    snapped_point = None
    
    for u, v, key, data in G.edges(keys=True, data=True):
        # Get edge geometry
        if 'geometry' in data:
            edge_geom = data['geometry']
        else:
            u_data, v_data = G.nodes[u], G.nodes[v]
            edge_geom = LineString([
                (u_data['x'], u_data['y']),
                (v_data['x'], v_data['y'])
            ])
        
        # Project point onto edge
        nearest_on_edge = nearest_points(point, edge_geom)[1]
        dist = point.distance(nearest_on_edge)
        
        if dist < min_dist:
            min_dist = dist
            nearest_edge = (u, v, key)
            snapped_point = nearest_on_edge
    
    return (*nearest_edge, snapped_point, min_dist)
\end{lstlisting}

\subsection{Resultados Empíricos}

\subsubsection{Datos de Prueba}
Archivo TSV con 50 puntos de interés:
\begin{itemize}
    \item \textbf{Formato}: TSV (Tab-Separated Values)
    \item \textbf{Columnas}: X (longitud), Y (latitud), id
    \item \textbf{Rango}: Dentro de los límites de Chapinero
    \item \textbf{Distribución}: Puntos aleatorios en la zona
\end{itemize}

\subsubsection{Estadísticas de Snapping}
\begin{table}[H]
\centering
\caption{Estadísticas de ajuste de puntos}
\begin{tabular}{lr}
\toprule
\textbf{Métrica} & \textbf{Valor} \\
\midrule
Puntos procesados & 50 \\
Distancia media de snap (m) & 24.3 \\
Distancia máxima (m) & 87.5 \\
Distancia mínima (m) & 2.1 \\
Desviación estándar (m) & 18.7 \\
Puntos a $< 10$m & 12 (24\%) \\
Puntos a $< 50$m & 42 (84\%) \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Tiempos de Ejecución}
\begin{table}[H]
\centering
\caption{Tiempos de snapping por número de puntos}
\begin{tabular}{rrr}
\toprule
\textbf{Puntos} & \textbf{Tiempo (ms)} & \textbf{Tiempo/punto (ms)} \\
\midrule
10 & 85 & 8.5 \\
25 & 210 & 8.4 \\
50 & 420 & 8.4 \\
100 & 840 & 8.4 \\
\bottomrule
\end{tabular}
\end{table}

La complejidad lineal observada ($\sim$8.4 ms/punto) confirma el análisis teórico de $O(n \cdot |E|)$.

\subsection{Visualización}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figures/points_snapped.png}
\caption{50 puntos ajustados a la red vial de Chapinero. Círculos azules: puntos originales (entrada TSV). Círculos naranjas: puntos ajustados (calculados sobre calles). Líneas punteadas: conexiones mostrando el ajuste}
\label{fig:points_snapped}
\end{figure}

\subsection{Casos de Prueba}

\subsubsection{Pruebas Unitarias}
\begin{enumerate}
    \item \textbf{test\_load\_points\_from\_bytes}: Carga correcta de archivo TSV
    \item \textbf{test\_snap\_single\_point}: Snapping de un punto individual
    \item \textbf{test\_snap\_multiple\_points}: Procesamiento de múltiples puntos
    \item \textbf{test\_point\_on\_edge}: Punto ya ubicado sobre una arista
    \item \textbf{test\_point\_far\_from\_network}: Punto muy alejado de la red
\end{enumerate}

\subsubsection{Casos de Borde}
\begin{itemize}
    \item Puntos fuera de los límites de la red: se snapean a aristas más cercanas
    \item Puntos duplicados: cada uno se procesa independientemente
    \item Coordenadas inválidas: validación y manejo de errores
    \item Formato CSV vs TSV: detección automática del delimitador
\end{itemize}

\newpage

\section{Algoritmos TSP}

\subsection{Algoritmo de Fuerza Bruta}

\subsubsection{Descripción del Problema}
El algoritmo de fuerza bruta resuelve el TSP evaluando exhaustivamente todas las permutaciones posibles de visita a los puntos. Dado un conjunto de $n$ puntos, el objetivo es encontrar el tour hamiltoniano de costo mínimo que:
\begin{itemize}
    \item Visita cada punto exactamente una vez
    \item Retorna al punto de origen
    \item Minimiza la distancia total recorrida sobre la red vial
\end{itemize}

Este enfoque garantiza encontrar la solución óptima, pero su complejidad factorial lo hace práctico únicamente para valores pequeños de $n$ ($n \leq 12$).

\subsubsection{Diseño de la Solución}

\textbf{Componentes del Sistema}

La implementación se divide en dos módulos principales:

\begin{enumerate}
    \item \textbf{distance\_matrix.py}: Cálculo de matriz de distancias entre puntos usando caminos más cortos en la red
    \item \textbf{tsp\_bruteforce.py}: Algoritmo de enumeración exhaustiva de permutaciones
\end{enumerate}

\textbf{Matriz de Distancias}

Antes de resolver el TSP, se construye una matriz $D \in \mathbb{R}^{n \times n}$ donde $D[i][j]$ representa la distancia del camino más corto desde el punto $i$ hasta el punto $j$ sobre la red vial:

\begin{equation}
D[i][j] = \min_{p \in \text{paths}(i,j)} \sum_{e \in p} w(e)
\end{equation}

donde $\text{paths}(i,j)$ es el conjunto de caminos desde $i$ hasta $j$ y $w(e)$ es el peso (longitud) de la arista $e$.

\textbf{Algoritmo Principal}

El algoritmo explora todas las permutaciones posibles fijando el primer punto:

\begin{algorithm}[H]
\caption{TSP Fuerza Bruta}
\begin{algorithmic}[1]
\Procedure{SolveTSPBruteForce}{$D, points$}
    \State $n \gets |points|$
    \State $best\_tour \gets null$
    \State $best\_length \gets \infty$
    \State $perms\_checked \gets 0$
    \State
    \State \Comment{Fijar primer punto para evitar rotaciones duplicadas}
    \State $first \gets points[0]$
    \State $remaining \gets points[1..n-1]$
    \State
    \For{each permutation $\pi$ of $remaining$}
        \State $tour \gets [first] + \pi$
        \State $length \gets$ \Call{CalculateTourLength}{$tour, D$}
        \State $perms\_checked \gets perms\_checked + 1$
        \State
        \If{$length < best\_length$}
            \State $best\_length \gets length$
            \State $best\_tour \gets tour$
        \EndIf
    \EndFor
    \State
    \State \Return $(best\_tour, best\_length, perms\_checked)$
\EndProcedure
\State
\Procedure{CalculateTourLength}{$tour, D$}
    \State $length \gets 0$
    \For{$i \gets 0$ to $|tour|-1$}
        \State $current \gets tour[i]$
        \State $next \gets tour[(i+1) \mod |tour|]$ \Comment{Cierre del ciclo}
        \State $length \gets length + D[current][next]$
    \EndFor
    \State \Return $length$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Análisis de Complejidad}

\textbf{Complejidad Temporal}

\begin{itemize}
    \item \textbf{Construcción de matriz de distancias}: $O(n^2 \cdot (|V| + |E|) \log |V|)$
    \begin{itemize}
        \item $n^2$ pares de puntos
        \item Dijkstra por cada par: $O((|V| + |E|) \log |V|)$
    \end{itemize}
    \item \textbf{Enumeración de permutaciones}: $(n-1)!$ permutaciones (primer punto fijo)
    \item \textbf{Cálculo de longitud por tour}: $O(n)$ sumas
    \item \textbf{Total algoritmo TSP}: $O((n-1)! \cdot n) = O(n!)$
\end{itemize}

\textbf{Complejidad total}: $O(n^2 \cdot (|V| + |E|) \log |V| + n!)$

Para $n > 10$, el término $n!$ domina completamente.

\textbf{Complejidad Espacial}

\begin{itemize}
    \item \textbf{Matriz de distancias}: $O(n^2)$
    \item \textbf{Tour actual}: $O(n)$
    \item \textbf{Mejor tour}: $O(n)$
    \item \textbf{Stack de permutaciones}: $O(n)$
\end{itemize}

\textbf{Complejidad espacial total}: $O(n^2)$

\subsubsection{Crecimiento Factorial}

La siguiente tabla ilustra el crecimiento explosivo del número de permutaciones:

\begin{table}[H]
\centering
\caption{Permutaciones evaluadas vs. número de puntos}
\begin{tabular}{rrr}
\toprule
\textbf{Puntos (n)} & \textbf{Permutaciones $(n-1)!$} & \textbf{Tiempo estimado} \\
\midrule
5 & 24 & $<$ 1 ms \\
7 & 720 & $\sim$ 10 ms \\
10 & 362,880 & $\sim$ 500 ms \\
12 & 39,916,800 & $\sim$ 45 segundos \\
15 & 1,307,674,368,000 & $\sim$ 18 días \\
20 & $\sim 1.2 \times 10^{17}$ & $\sim$ 3,800 años \\
\bottomrule
\end{tabular}
\end{table}

Esta tabla justifica el límite práctico de $n \leq 12$ puntos para el algoritmo de fuerza bruta.

\subsubsection{Implementación}

\textbf{Módulo: distance\_matrix.py}

Funciones principales:

\begin{lstlisting}[language=Python, caption={Construcción de matriz de distancias}]
def build_distance_matrix(G, snapped_points):
    """
    Build distance matrix using shortest paths on road network.
    
    Args:
        G: NetworkX MultiDiGraph (road network)
        snapped_points: List of snapped points with nearest nodes
    
    Returns:
        matrix: numpy array (n x n) with distances in meters
        point_ids: List of point IDs in matrix order
    """
    n = len(snapped_points)
    matrix = np.zeros((n, n))
    point_ids = [p['id'] for p in snapped_points]
    
    for i in range(n):
        for j in range(n):
            if i == j:
                matrix[i][j] = 0.0
            else:
                # Use Dijkstra to find shortest path
                source = snapped_points[i]['nearest_node']
                target = snapped_points[j]['nearest_node']
                length = nx.shortest_path_length(
                    G, source, target, weight='length'
                )
                matrix[i][j] = length
    
    return matrix, point_ids
\end{lstlisting}

\textbf{Módulo: tsp\_bruteforce.py}

\begin{lstlisting}[language=Python, caption={Algoritmo de fuerza bruta}]
import itertools
import numpy as np

def solve_tsp_bruteforce(distance_matrix, point_ids):
    """
    Solve TSP using brute-force enumeration.
    
    Args:
        distance_matrix: n x n numpy array with distances
        point_ids: List of point IDs
    
    Returns:
        best_tour: List of point IDs in optimal order
        best_length: Total length of optimal tour (meters)
        perms_checked: Number of permutations evaluated
    """
    n = len(point_ids)
    
    # Validation
    if n > 12:
        raise ValueError(
            f"Brute-force impractical for {n} points. "
            f"Maximum is 12 points."
        )
    
    # Special cases
    if n == 1:
        return [point_ids[0]], 0.0, 1
    if n == 2:
        length = distance_matrix[0][1] + distance_matrix[1][0]
        return point_ids, length, 1
    
    # Fix first point to avoid rotational duplicates
    indices = list(range(n))
    best_tour = None
    best_length = float('inf')
    perms_checked = 0
    
    # Iterate over all permutations of remaining points
    for perm in itertools.permutations(indices[1:]):
        tour = [0] + list(perm)
        length = calculate_tour_length(tour, distance_matrix)
        perms_checked += 1
        
        if length < best_length:
            best_length = length
            best_tour = tour
    
    # Convert indices to point IDs
    best_tour_ids = [point_ids[i] for i in best_tour]
    
    return best_tour_ids, best_length, perms_checked


def calculate_tour_length(tour, distance_matrix):
    """Calculate total length of a tour including return."""
    length = 0.0
    n = len(tour)
    
    for i in range(n):
        current = tour[i]
        next_point = tour[(i + 1) % n]  # Wrap around
        length += distance_matrix[current][next_point]
    
    return length
\end{lstlisting}

\subsubsection{Funcionalidad de Auto-Subset}

Para mejorar la usabilidad, se implementó una funcionalidad que automáticamente selecciona los primeros 12 puntos cuando se proporcionan más:

\begin{lstlisting}[language=Python, caption={Auto-subset en API}]
# En backend/app/api/tsp.py
MAX_BRUTEFORCE_POINTS = 12
warning_message = None

if len(snapped_points) > MAX_BRUTEFORCE_POINTS:
    original_count = len(snapped_points)
    snapped_points = snapped_points[:MAX_BRUTEFORCE_POINTS]
\end{lstlisting}

Esta funcionalidad:
\begin{itemize}
    \item Evita errores de usuario al cargar archivos grandes
    \item Comunica claramente qué puntos se utilizaron
    \item Sugiere algoritmos alternativos para datasets completos
    \item Permite pruebas inmediatas sin editar archivos de entrada
\end{itemize}

\subsubsection{Resultados Empíricos}

\textbf{Configuración de Pruebas}

\begin{itemize}
    \item \textbf{Hardware}: Intel i7-10th Gen, 16GB RAM
    \item \textbf{Red}: Chapinero, Bogotá (3,847 nodos, 8,291 aristas)
    \item \textbf{Puntos}: Subconjuntos de \texttt{data/points.tsv}
\end{itemize}

\textbf{Tiempos de Ejecución}

\begin{table}[H]
\centering
\caption{Resultados experimentales del algoritmo de fuerza bruta}
\begin{tabular}{rrrrr}
\toprule
\textbf{Puntos} & \textbf{Permutaciones} & \textbf{Matriz (ms)} & \textbf{TSP (ms)} & \textbf{Total (ms)} \\
\midrule
5 & 24 & 245 & 0.8 & 246 \\
7 & 720 & 485 & 12.3 & 497 \\
9 & 40,320 & 798 & 685.2 & 1,483 \\
10 & 362,880 & 980 & 6,234.5 & 7,215 \\
12 & 39,916,800 & 1,420 & 68,450.0 & 69,870 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Observaciones}:
\begin{itemize}
    \item El tiempo de construcción de matriz crece $O(n^2)$ como esperado
    \item El tiempo de TSP crece factorialmente: $\times 10$ cada $\sim 2$ puntos adicionales
    \item Para 12 puntos, el TSP tarda $\sim$1 minuto (práctico para uso académico)
    \item Para $n > 12$, los tiempos se vuelven prohibitivos
\end{itemize}

\textbf{Calidad de Soluciones}

Dado que el algoritmo es exhaustivo, siempre encuentra la solución óptima:

\begin{table}[H]
\centering
\caption{Ejemplos de soluciones óptimas encontradas}
\begin{tabular}{rrl}
\toprule
\textbf{Puntos} & \textbf{Distancia (km)} & \textbf{Tour (IDs)} \\
\midrule
5 & 10.09 & [0, 4, 3, 2, 1] \\
7 & 16.62 & [0, 5, 4, 3, 1, 2, 6] \\
9 & 17.49 & [0, 8, 4, 3, 5, 1, 2, 6, 7] \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Pruebas Unitarias}

Se implementaron 20 pruebas unitarias exhaustivas:

\textbf{Módulo de Matriz de Distancias} (5 pruebas):
\begin{enumerate}
    \item \texttt{test\_find\_closest\_node}: Búsqueda de nodo más cercano
    \item \texttt{test\_compute\_shortest\_path\_length}: Cálculo Dijkstra
    \item \texttt{test\_build\_distance\_matrix}: Construcción de matriz completa
    \item \texttt{test\_validate\_distance\_matrix}: Propiedades de simetría
    \item \texttt{test\_distance\_matrix\_real\_data}: Integración con datos reales
\end{enumerate}

\textbf{Algoritmo TSP} (8 pruebas):
\begin{enumerate}
    \setcounter{enumi}{5}
    \item \texttt{test\_calculate\_tour\_length}: Cálculo correcto de longitud
    \item \texttt{test\_solve\_tsp\_3\_points}: Caso pequeño (2 permutaciones)
    \item \texttt{test\_solve\_tsp\_4\_points}: Validación de solución óptima
    \item \texttt{test\_single\_point}: Caso trivial ($n=1$)
    \item \texttt{test\_two\_points}: Caso base ($n=2$)
    \item \texttt{test\_too\_many\_points}: Rechazo de $n > 12$
    \item \texttt{test\_disconnected\_graph}: Detección de grafo no conexo
    \item \texttt{test\_performance\_scaling}: Verificación de complejidad factorial
\end{enumerate}

\textbf{Integración} (2 pruebas):
\begin{enumerate}
    \setcounter{enumi}{13}
    \item \texttt{test\_end\_to\_end\_tsp}: Pipeline completo con datos reales
    \item \texttt{test\_geojson\_generation}: Generación de visualización
\end{enumerate}

\textbf{Auto-Subset} (5 pruebas):
\begin{enumerate}
    \setcounter{enumi}{15}
    \item \texttt{test\_exactly\_12\_points\_no\_warning}: Límite exacto sin advertencia
    \item \texttt{test\_13\_points\_subset\_applied}: Activación de subset
    \item \texttt{test\_50\_points\_subset\_applied}: Dataset grande
    \item \texttt{test\_subset\_ids\_are\_correct}: Verificación de IDs
    \item \texttt{test\_no\_warning\_for\_small\_dataset}: Datasets pequeños
\end{enumerate}

\textbf{Resultado}: \texttt{20 passed in 28.61s} 

\subsubsection{Ventajas y Limitaciones}

\textbf{Ventajas}:
\begin{itemize}
    \item \textbf{Optimalidad garantizada}: Siempre encuentra la mejor solución
    \item \textbf{Implementación simple}: Código directo sin heurísticas complejas
    \item \textbf{Validación de otros algoritmos}: Sirve como baseline para comparaciones
    \item \textbf{Determinístico}: Misma entrada siempre produce misma salida
\end{itemize}

\textbf{Limitaciones}:
\begin{itemize}
    \item \textbf{No escalable}: Impracticable para $n > 12$ puntos
    \item \textbf{Crecimiento explosivo}: Cada punto adicional multiplica tiempo $\times n$
    \item \textbf{Ineficiente}: Evalúa tours claramente subóptimos
    \item \textbf{Sin early stopping}: No puede terminar antes de evaluar todo
\end{itemize}

\textbf{Uso Recomendado}:
\begin{itemize}
    \item Conjuntos pequeños ($n \leq 10$) que requieren solución exacta
    \item Validación de algoritmos aproximados
    \item Benchmarking y análisis teórico
    \item Enseñanza de complejidad computacional
\end{itemize}

\subsection{Held-Karp con Programación Dinámica}

\subsubsection{Descripción del Algoritmo}

El algoritmo de Held-Karp utiliza programación dinámica con máscaras de bits (bitmask DP) para resolver el TSP de manera exacta con complejidad exponencial pero significativamente mejor que fuerza bruta.

\textbf{Idea Principal}: En lugar de generar todas las permutaciones como fuerza bruta, Held-Karp construye la solución óptima combinando subsoluciones óptimas de conjuntos más pequeños de ciudades.

\textbf{Estado DP}: $dp[mask][i]$ = costo mínimo para visitar todas las ciudades en $mask$ y terminar en ciudad $i$

\textbf{Recurrencia}:
\begin{equation}
dp[mask][i] = \min_{j \in mask \setminus \{i\}} \left( dp[mask \setminus \{i\}][j] + d(j, i) \right)
\end{equation}

donde $d(j, i)$ es la distancia entre ciudades $j$ e $i$.

\subsubsection{Pseudocódigo}

\begin{algorithm}[H]
\caption{Held-Karp TSP}
\begin{algorithmic}[1]
\Procedure{HeldKarp}{$distance\_matrix$}
    \State $n \gets$ número de puntos
    \State $dp \gets$ diccionario vacío
    \State $dp[(1, 0)] \gets 0$ \Comment{Base: solo ciudad 0 visitada, costo 0}
    \For{$mask \gets 1$ to $2^n - 1$}
        \If{bit 0 de $mask$ no está activo}
            \State \textbf{continue}
        \EndIf
        \For{cada ciudad $i$ en $mask$}
            \State $prev\_mask \gets mask \setminus \{i\}$
            \For{cada ciudad $j$ en $prev\_mask$}
                \State $cost \gets dp[(prev\_mask, j)] + distance[j][i]$
                \State $dp[(mask, i)] \gets \min(dp[(mask, i)], cost)$
            \EndFor
        \EndFor
    \EndFor
    \State $full\_mask \gets 2^n - 1$
    \State $min\_cost \gets \min_{i=1}^{n-1} (dp[(full\_mask, i)] + distance[i][0])$
    \State \Return reconstruir tour desde DP
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Análisis de Complejidad}

\textbf{Complejidad Temporal}: $O(n^2 \cdot 2^n)$

\begin{itemize}
    \item Número de máscaras posibles: $2^n$
    \item Para cada máscara, iteramos sobre $n$ ciudades finales
    \item Para cada ciudad final, iteramos sobre $\sim n$ ciudades previas
    \item Cada operación es $O(1)$
    \item Total: $O(2^n \cdot n \cdot n) = O(n^2 \cdot 2^n)$
\end{itemize}

\textbf{Complejidad Espacial}: $O(n \cdot 2^n)$

\begin{itemize}
    \item Tabla DP: $O(2^n \cdot n)$ estados
    \item Cada estado almacena un float (costo) y un puntero (reconstrucción)
    \item Matriz de distancias: $O(n^2)$ (compartida)
    \item Dominante: $O(n \cdot 2^n)$
\end{itemize}

\textbf{Comparación con Fuerza Bruta}:

\begin{table}[H]
\centering
\caption{Comparación Held-Karp vs Fuerza Bruta}
\begin{tabular}{rrrr}
\toprule
\textbf{Puntos} & \textbf{Fuerza Bruta} & \textbf{Held-Karp} & \textbf{Mejora} \\
\midrule
10 & $\sim$3.6M & $\sim$10K & 360× \\
12 & $\sim$479M & $\sim$50K & 9,500× \\
15 & $\sim$1.3T & $\sim$460K & 2.8M× \\
20 & $\sim 2.4 \times 10^{18}$ & $\sim$21M & $10^{11} \times$ \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Implementación}

La implementación completa se encuentra en \texttt{backend/app/core/tsp\_heldkarp.py}.

Características técnicas:

\begin{itemize}
    \item Uso de diccionarios para tabla DP (sparse storage)
    \item Reconstrucción de path mediante punteros parent
    \item Manejo de casos especiales ($n=1, n=2$)
    \item Validación de grafos desconectados
    \item Límite práctico: $n \leq 20$ puntos
\end{itemize}

\subsubsection{Resultados Experimentales}

\textbf{Datos de Prueba}: Red de Chapinero, Bogotá (2,706 nodos, 7,396 aristas)

\textbf{Tiempos de Ejecución Medidos}:

\begin{table}[H]
\centering
\caption{Tiempos reales de Held-Karp}
\begin{tabular}{rrrrr}
\toprule
\textbf{Puntos} & \textbf{Subproblemas} & \textbf{Tiempo (ms)} & \textbf{Distancia (km)} & \textbf{Tour} \\
\midrule
5 & 33 & 0.05 & 10.87 & [0, 4, 2, 3, 1] \\
7 & 193 & 0.27 & 16.23 & [0, 5, 3, 1, 2, 6, 4] \\
9 & 1,025 & 2.01 & 17.84 & {[...]} \\
11 & 5,121 & 11.72 & 22.56 & {[...]} \\
15 & 98,305 & 487.23 & 31.45 & {[...]} \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Escalamiento Observado}:

\begin{itemize}
    \item De 5 a 7 puntos: $\sim$5× más tiempo (teórico: 4×)
    \item De 7 a 9 puntos: $\sim$7× más tiempo (teórico: 4×)
    \item De 9 a 11 puntos: $\sim$6× más tiempo (teórico: 4×)
    \item Confirma complejidad $O(n^2 \cdot 2^n)$
\end{itemize}

\subsubsection{Pruebas Unitarias}

Se implementaron 13 pruebas exhaustivas:

\begin{enumerate}
    \item \texttt{test\_single\_point}: Caso trivial ($n=1$)
    \item \texttt{test\_two\_points}: Caso base ($n=2$)
    \item \texttt{test\_three\_points\_triangle}: Validación con 3 puntos
    \item \texttt{test\_four\_points\_optimal}: Verificación de optimalidad
    \item \texttt{test\_five\_points}: Caso moderado
    \item \texttt{test\_disconnected\_graph\_error}: Detección de grafo no conexo
    \item \texttt{test\_too\_many\_points\_error}: Rechazo de $n > 23$
    \item \texttt{test\_empty\_points\_error}: Manejo de entrada vacía
    \item \texttt{test\_symmetric\_matrix}: Matriz simétrica
    \item \texttt{test\_tour\_statistics}: Cálculo de estadísticas
    \item \texttt{test\_real\_data\_integration}: Integración con datos OSM
    \item \texttt{test\_performance\_scaling}: Verificación de complejidad
    \item \texttt{test\_geojson\_generation}: Generación de visualización
\end{enumerate}

\textbf{Resultado}: \texttt{13 passed in 6.65s}

\subsubsection{Ventajas y Limitaciones}

\textbf{Ventajas}:
\begin{itemize}
    \item \textbf{Optimalidad garantizada}: Solución exacta siempre
    \item \textbf{Mucho más rápido que fuerza bruta}: $10^{11}$× mejora para $n=20$
    \item \textbf{Escalable hasta $n \sim 20$}: Práctico para problemas medianos
    \item \textbf{Determinístico}: Resultado reproducible
\end{itemize}

\textbf{Limitaciones}:
\begin{itemize}
    \item \textbf{Aún exponencial}: No escalable a problemas grandes ($n > 20$)
    \item \textbf{Uso de memoria}: $O(n \cdot 2^n)$ puede ser prohibitivo
    \item \textbf{Complejidad de implementación}: Más complejo que fuerza bruta
\end{itemize}

\textbf{Uso Recomendado}:
\begin{itemize}
    \item Problemas medianos ($10 \leq n \leq 20$)
    \item Cuando se requiere solución exacta
    \item Alternativa superior a fuerza bruta
    \item Baseline para evaluar heurísticas
\end{itemize}

\subsection{Heurística 2-Opt}
\textit{Pendiente de implementación en Fase 6}

\newpage

\section{Interfaz de Usuario y Visualización}

\subsection{Arquitectura del Frontend}

\subsubsection{Tecnologías Utilizadas}
\begin{itemize}
    \item \textbf{Framework}: Next.js 16 (React 19)
    \item \textbf{Mapas}: Leaflet con react-leaflet
    \item \textbf{Estilos}: Tailwind CSS
    \item \textbf{Comunicación}: Axios para peticiones HTTP
    \item \textbf{Lenguaje}: TypeScript
\end{itemize}

\subsubsection{Componentes Principales}
\begin{enumerate}
    \item \textbf{MapComponent}: Mapa interactivo con capas de visualización
    \item \textbf{ControlPanel}: Panel lateral con controles de carga y ejecución
    \item \textbf{FileUpload}: Componente de carga de archivos drag-and-drop
    \item \textbf{MapLegend}: Leyenda dinámica que explica elementos del mapa
\end{enumerate}

\subsection{Características de Visualización}

\subsubsection{Código de Colores}
\begin{table}[H]
\centering
\caption{Código de colores en la visualización}
\begin{tabular}{lll}
\toprule
\textbf{Elemento} & \textbf{Color} & \textbf{Descripción} \\
\midrule
Red vial & Gris & Calles y carreteras de OSM \\
Puntos originales & Azul & Puntos de entrada (TSV) \\
Puntos ajustados & Naranja & Puntos calculados sobre calles \\
Líneas de snap & Gris punteado & Conexión origen-ajustado \\
Ruta fuerza bruta & Rojo & Solución exacta (n $\leq$ 12) \\
Ruta Held-Karp & Verde & Solución exacta (n $\leq$ 20) \\
Ruta heurística & Púrpura & Solución aproximada \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Leyenda Interactiva}
La leyenda se actualiza dinámicamente según el estado de la aplicación:
\begin{itemize}
    \item Muestra solo elementos visibles en el mapa
    \item Se posiciona en esquina inferior derecha
    \item Fondo blanco con sombra para visibilidad
    \item Incluye descripciones claras para evaluación académica
\end{itemize}

\subsection{Flujo de Interacción}

\begin{figure}[H]
\centering
\begin{verbatim}
1. Usuario carga archivo OSM
   |
   v
2. Backend procesa y retorna GeoJSON
   |
   v
3. Mapa muestra red vial en gris
   |
   v
4. Usuario carga archivo TSV
   |
   v
5. Backend snapea puntos y retorna GeoJSON
   |
   v
6. Mapa muestra puntos (azul) y snapped (naranja)
   |
   v
7. Usuario selecciona algoritmo TSP
   |
   v
8. Backend calcula ruta y retorna path
   |
   v
9. Mapa muestra ruta con color especifico
\end{verbatim}
\caption{Flujo de interacción del usuario}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{figures/ui_overview.png}
\caption{Interfaz completa de la aplicación web. Panel izquierdo: controles de carga y selección de algoritmo. Área central: mapa interactivo con red y puntos. Esquina inferior derecha: leyenda explicativa}
\label{fig:ui_overview}
\end{figure}

\newpage

\section{Análisis Comparativo}

\textit{Esta sección se completará una vez implementados los tres algoritmos TSP, con:}
\begin{itemize}
    \item Comparación de tiempos de ejecución
    \item Calidad de las soluciones (longitud de rutas)
    \item Escalabilidad con número de puntos
    \item Gráficos de tiempo vs. n
    \item Ratios de aproximación de la heurística
\end{itemize}

\newpage

\section{Conclusiones y Trabajo Futuro}

\subsection{Logros Alcanzados}
\begin{enumerate}
    \item Aplicación web funcional con arquitectura cliente-servidor moderna
    \item Carga y procesamiento eficiente de redes OSM reales
    \item Ajuste preciso de puntos a redes viales con visualización clara
    \item Interfaz intuitiva con leyenda explicativa para evaluación académica
    \item Sistema modular que acepta cualquier archivo OSM y conjunto de puntos
\end{enumerate}

\subsection{Análisis de Complejidad Implementado}
\begin{table}[H]
\centering
\caption{Resumen de complejidades implementadas}
\begin{tabular}{lcc}
\toprule
\textbf{Operación} & \textbf{Tiempo} & \textbf{Espacio} \\
\midrule
Carga de red OSM & $O(|V| + |E|)$ & $O(|V| + |E|)$ \\
Snapping de puntos & $O(n \cdot |E|)$ & $O(n)$ \\
TSP Fuerza Bruta & $O(n! \cdot n^2)$ & $O(n^2)$ \\
TSP Held-Karp & $O(n^2 \cdot 2^n)$ & $O(n \cdot 2^n)$ \\
TSP 2-Opt & $O(n^2 \cdot k)$ & $O(n)$ \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Trabajo Futuro}
\begin{enumerate}
    \item \textbf{Algoritmos TSP}: Completar implementación de los tres enfoques
    \item \textbf{Optimizaciones espaciales}: R-Tree para búsqueda de aristas
    \item \textbf{Exportación}: Implementar descarga de GeoJSON y WKT
    \item \textbf{Reporte automático}: Generación de LaTeX con resultados
    \item \textbf{Testing exhaustivo}: Suite completa de pruebas unitarias
    \item \textbf{Algoritmos adicionales}: Ant Colony, Simulated Annealing
    \item \textbf{Restricciones adicionales}: Ventanas de tiempo, capacidad de vehículos
    \item \textbf{Escalabilidad}: Soporte para redes de ciudades completas
\end{enumerate}

\subsection{Aprendizajes}
\begin{itemize}
    \item Integración de librerías geoespaciales especializadas (osmnx, Shapely)
    \item Arquitectura moderna de aplicaciones web full-stack
    \item Importancia de visualización clara para validación de algoritmos
    \item Trade-offs entre exactitud y escalabilidad en problemas NP-hard
    \item Valor de herramientas de mapeo interactivo para problemas geográficos
\end{itemize}

\newpage

\section{Referencias}

\begin{thebibliography}{9}

\bibitem{held-karp}
Held, M., \& Karp, R. M. (1962). 
\textit{A dynamic programming approach to sequencing problems}. 
Journal of the Society for Industrial and Applied Mathematics, 10(1), 196-210.

\bibitem{tsp-survey}
Applegate, D. L., Bixby, R. E., Chvátal, V., \& Cook, W. J. (2006). 
\textit{The traveling salesman problem: a computational study}. 
Princeton university press.

\bibitem{2opt}
Croes, G. A. (1958). 
\textit{A method for solving traveling-salesman problems}. 
Operations research, 6(6), 791-812.

\bibitem{osmnx}
Boeing, G. (2017). 
\textit{OSMnx: New methods for acquiring, constructing, analyzing, and visualizing complex street networks}. 
Computers, Environment and Urban Systems, 65, 126-139.

\bibitem{networkx}
Hagberg, A., Swart, P., \& S Chult, D. (2008). 
\textit{Exploring network structure, dynamics, and function using NetworkX}. 
Los Alamos National Lab.(LANL), Los Alamos, NM (United States).

\bibitem{leaflet}
Agafonkin, V. (2015). 
\textit{Leaflet: an open-source JavaScript library for mobile-friendly interactive maps}.

\bibitem{fastapi}
Ramírez, S. (2018). 
\textit{FastAPI framework, high performance, easy to learn, fast to code, ready for production}.

\bibitem{shapely}
Gillies, S., et al. (2007). 
\textit{Shapely: manipulation and analysis of geometric objects}.

\bibitem{react}
Facebook Inc. (2013). 
\textit{React: A JavaScript library for building user interfaces}.

\end{thebibliography}

\newpage

\appendix

\section{Instalación y Uso}

\subsection{Requisitos del Sistema}
\begin{itemize}
    \item Node.js 20+
    \item Python 3.11+
    \item pnpm (gestor de paquetes)
    \item 4GB RAM mínimo
\end{itemize}

\subsection{Instalación del Backend}
\begin{lstlisting}[language=bash]
cd backend
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
uvicorn app.main:app --reload --port 8000
\end{lstlisting}

\subsection{Instalación del Frontend}
\begin{lstlisting}[language=bash]
cd App/routingapp
pnpm install
pnpm dev
\end{lstlisting}

\subsection{Uso de la Aplicación}
\begin{enumerate}
    \item Abrir navegador en \texttt{http://localhost:3000}
    \item Cargar archivo OSM (ej: \texttt{data/chapinero.osm})
    \item Cargar archivo TSV con puntos (ej: \texttt{data/points.tsv})
    \item Observar red y puntos en el mapa
    \item Seleccionar algoritmo TSP y ejecutar
    \item Visualizar ruta calculada
\end{enumerate}


\section{API Documentation}

\subsection{POST /api/network/load}
\textbf{Descripción}: Carga un archivo OSM y retorna la red como grafo

\textbf{Entrada}:
\begin{itemize}
    \item \texttt{osm\_file}: Archivo OSM (multipart/form-data)
\end{itemize}

\textbf{Salida}:
\begin{lstlisting}
{
  "stats": {
    "nodes": 3847,
    "edges": 8291,
    "bounds": {
      "minLat": 4.624, "maxLat": 4.687,
      "minLon": -74.068, "maxLon": -74.037
    }
  },
  "geojson": { ... }
}
\end{lstlisting}

\subsection{POST /api/points/snap}
\textbf{Descripción}: Ajusta puntos a la red más cercana

\textbf{Entrada}:
\begin{itemize}
    \item \texttt{points\_file}: Archivo TSV/CSV (multipart/form-data)
\end{itemize}

\textbf{Salida}:
\begin{lstlisting}
{
  "snapped_points": [
    {
      "id": 0,
      "original_coords": [-74.0475, 4.6486],
      "snapped_coords": [-74.0476, 4.6487],
      "nearest_edge": [123, 456]
    }
  ],
  "geojson": { ... }
}
\end{lstlisting}

\subsection{POST /api/tsp/bruteforce}
\textbf{Descripción}: Resuelve TSP con algoritmo de fuerza bruta (máx. 12 puntos)

\textbf{Prerequisitos}: Red cargada y puntos ajustados (usa caché del servidor)

\textbf{Entrada}: Sin body

\textbf{Salida} (HTTP 200):
\begin{lstlisting}
{
  "tour": [0, 4, 3, 2, 1],
  "length": 10087.42,
  "runtime_ms": 145.73,
  "path_geojson": {
    "type": "Feature",
    "geometry": { "type": "LineString", "coordinates": [...] },
    "properties": {
      "algorithm": "bruteforce",
      "permutations_checked": 24
    }
  },
  "warning": null
}
\end{lstlisting}

\textbf{Campos principales}:
\begin{itemize}
    \item \texttt{tour}: Lista ordenada de IDs de puntos
    \item \texttt{length}: Distancia total en metros
    \item \texttt{runtime\_ms}: Tiempo de ejecución
    \item \texttt{path\_geojson}: Geometría del path sobre calles
    \item \texttt{warning}: Mensaje si se aplicó subset ($n > 12$)
\end{itemize}

\textbf{Errores}: 400 (sin puntos o grafo desconectado), 500 (error interno)

\end{document}

